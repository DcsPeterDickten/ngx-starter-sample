import { Injectable, InjectionToken, NgModule, Inject, LOCALE_ID } from '@angular/core';
import 'rxjs/add/operator/first';
import { applyMiddleware, compose, createStore } from 'redux';
import { fromJS, Map, is, List } from 'immutable';
import persistState from 'redux-localstorage';
import transit from 'transit-immutable-js';
import { createLogger } from 'redux-logger';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/takeUntil';
import { __decorate, __metadata } from 'tslib';
import { dispatch, NgRedux } from '@angular-redux/store';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { HttpClient } from '@angular/common/http';
import { normalize, denormalize } from 'normalizr';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/share';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import 'rxjs/add/operator/distinctUntilChanged';
import { combineReducers } from 'redux-immutable';
import { enableBatching } from 'redux-batched-actions';
import { combineEpics, createEpicMiddleware } from 'redux-observable';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/observable/empty';
import { routerReducer } from '@angular-redux/router';
import { createSelectorCreator, defaultMemoize } from 'reselect';
import Ajv from 'ajv';
import { isInt, isFQDN, isMobilePhone, isEmail } from 'validator';
import { parse, isValid } from 'date-fns';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generate standardized action names, used mainly for the normalized reducers.
 *
 * For all the CRUD actions all 4 actions (base, start, next, error) are created.
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @return {?}
 */
function generateCrudActionNames(entityName, namespace) {
    const /** @type {?} */ BASE_NAME = namespace
        ? `${namespace.toLocaleUpperCase()}_${entityName.toLocaleUpperCase()}`
        : entityName.toLocaleUpperCase();
    const /** @type {?} */ START = 'START';
    const /** @type {?} */ NEXT = 'NEXT';
    const /** @type {?} */ ERROR = 'ERROR';
    const /** @type {?} */ READ = `${BASE_NAME}_READ`;
    const /** @type {?} */ READ_ONE = `${BASE_NAME}_READ_ONE`;
    const /** @type {?} */ CREATE = `${BASE_NAME}_CREATE`;
    const /** @type {?} */ UPDATE = `${BASE_NAME}_UPDATE`;
    const /** @type {?} */ DELETE = `${BASE_NAME}_DELETE`;
    return {
        read: READ,
        readStart: `${READ}_${START}`,
        readNext: `${READ}_${NEXT}`,
        readNextUpdate: `${READ}_${NEXT}_UPDATE`,
        readError: `${READ}_${ERROR}`,
        readOne: READ_ONE,
        readOneStart: `${READ_ONE}_${START}`,
        readOneNext: `${READ_ONE}_${NEXT}`,
        readOneNextUpdate: `${READ_ONE}_${NEXT}_UPDATE`,
        readOneError: `${READ_ONE}_${ERROR}`,
        create: CREATE,
        createStart: `${CREATE}_${START}`,
        createNext: `${CREATE}_${NEXT}`,
        createError: `${CREATE}_${ERROR}`,
        update: UPDATE,
        updateStart: `${UPDATE}_${START}`,
        updateNext: `${UPDATE}_${NEXT}`,
        updateError: `${UPDATE}_${ERROR}`,
        delete: DELETE,
        deleteStart: `${DELETE}_${START}`,
        deleteNext: `${DELETE}_${NEXT}`,
        deleteError: `${DELETE}_${ERROR}`,
        setCurrent: `${BASE_NAME}_SET_CURRENT`,
        reset: `${BASE_NAME}_RESET`,
        resetError: `${BASE_NAME}_RESET_ERROR`,
    };
}
/**
 * Tests if a normalized subState has data that is too old.
 *
 * Given the maxAge, it tests if the data is already loaded and not older than maxAge.
 *
 * @export
 * @param {?} state
 * @param {?=} maxAge
 * @return {?}
 */
function subStateStale(state, maxAge = 0) {
    const /** @type {?} */ updatedAt = state.get('updatedAt');
    return updatedAt === 0 || Date.now() - updatedAt - maxAge > 0;
}
/**
 * Tests if a normalized state has a specific model instace
 *
 * @export
 * @param {?} collectionSubState the given state
 * @param {?} entitiesName the name of the collection in entities
 * @param {?} id the id of the model instance to fetch
 * @param {?=} maxAge
 * @return {?}
 */
function hasModel(collectionSubState, entitiesName, id, maxAge) {
    id = String(id);
    if (maxAge) {
        const /** @type {?} */ updatedAt = collectionSubState.get('updatedAt');
        const /** @type {?} */ dataCurrent = Date.now() - updatedAt - maxAge < 0;
        if (!dataCurrent) {
            return false;
        }
    }
    return collectionSubState.hasIn(['entities', entitiesName, id]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for smart/container Components.
 *
 * This is used for Components with store data access.
 *
 * @export
 */
class ContainerComponent {
    constructor() {
        this.subscriptions = [];
    }
    /**
     * Default OnDestroy callback that unsubscribes from all rxjs Subscriptions of this component.
     *
     * \@memberof ContainerComponent
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
        this.subscriptions = [];
    }
    /**
     * Wrapper around [[Observable.subscribe]] that saves the [[Subscription]] to be removed later.
     *
     * \@memberof ContainerComponent
     * @template T
     * @param {?} obs
     * @param {?} callback
     * @return {?}
     */
    subscribeToObservable(obs, callback) {
        this.subscriptions.push(obs.subscribe(callback.bind(this)));
    }
    /**
     * Shortcut function to always have the current value from an [[Observable]] available in the [[Component]]
     *
     * \@memberof ContainerComponent
     * @template T
     * @param {?} obs The Observable to get the data from.
     * @param {?} propertyName The name of the property where to store the data in.
     * @return {?}
     */
    valueFromObservable(obs, propertyName) {
        this.subscribeToObservable(obs, (data) => {
            this[propertyName] = data;
        });
    }
    /**
     * Helper function to execute a callback only, if a [[INormalizedCollectionState]] has stale data.
     *
     * Usually used to check if the data in a selector is too old and the dispatch the read data action.
     *
     * \@memberof ContainerComponent
     * @param {?} subState$
     * @param {?} maxAge
     * @param {?} callback
     * @return {?}
     */
    executeIfStateStale(subState$, maxAge, callback) {
        subState$.first().subscribe(subState => {
            if (subStateStale(subState, maxAge)) {
                callback();
            }
        });
    }
}
ContainerComponent.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ContainerComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for *dumb* components
 *
 * Data is transfered via Inputs and Outputs, no Store or Actions allowed.
 *
 * @export
 */
class PresentationalComponent {
    /**
     * ImmutableJS aware track function
     *
     * Mainly used in ngFor trackBy
     *
     * \@memberOf PresentationalComponent
     * @param {?} _
     * @param {?} item
     * @return {?}
     *
     */
    identify(_, item) {
        if (typeof item.hashCode !== 'function') {
            throw new TypeError(`Given item is not of type Immutable, ${item.toString()} given!`);
        }
        return item.hashCode();
    }
    /**
     * Tests, wether a form component has errors
     *
     * \@memberOf PresentationalComponent
     * @param {?} form
     * @param {?} fieldName
     * @param {?=} errorName
     * @return {?}
     *
     */
    hasError(form, fieldName, errorName) {
        const /** @type {?} */ control = /** @type {?} */ (form.get(fieldName));
        if (control.untouched) {
            return false;
        }
        if (errorName) {
            return !!(control.errors && control.errors[errorName]);
        }
        else {
            return !!control.errors;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Helper function to setup the redux store with reducers, middleware and enhancers.
 *
 * @export
 * @param {?} rootReducer
 * @param {?=} initialState
 * @param {?=} middleware
 * @param {?=} enhancers
 * @return {?}
 */
function createReduxStore(rootReducer, initialState = fromJS({}), middleware = [], enhancers = []) {
    return /** @type {?} */ (createStore(rootReducer, initialState, compose(applyMiddleware(...middleware), ...enhancers)));
}
/**
 * Redux [[GenericStoreEnhancer]] that persists all state changes to localStorage,
 * knowing how to handle an ImmutableJS state.
 *
 * @export
 * @param {?=} paths
 * @return {?}
 */
function persistStateEnhancer(paths) {
    const /** @type {?} */ converter = transit.withFilter((value) => {
        return !(value instanceof Error);
    });
    return persistState(paths, {
        serialize: (state) => converter.toJSON(state),
        deserialize: (data) => converter.fromJSON(data),
        merge: (initialState, persistedState) => initialState.merge(persistedState),
        slicer: (statePaths) => {
            return (state) => {
                if (typeof statePaths === 'string') {
                    return state.filter((_, k) => k === statePaths);
                }
                else if (Array.isArray(statePaths)) {
                    return state.filter((_, k) => statePaths.indexOf(k) !== -1);
                }
                else {
                    return state;
                }
            };
        },
    });
}
/**
 * Selector function to return the current router substate.
 *
 * @export
 * @param {?} state
 * @return {?} string
 */
function routerStateSelector(state) {
    return state.get('router');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Middleware to automatically dispatch async actions when getting an Observable as payload
 *
 * It dispatches a _START action at once,
 * a _NEXT action for every next tick with the result data of the next as payload
 * and a _ERROR action, should the Observable generate an exception.
 *
 * If the initial action includes an Observable in action.meta.cancel, this is used to cancel out the
 * _NEXT actions as soon as this one fires once.
 *
 * @param store
 * @param action
 */
const observableMiddleware = (store) => (next) => (action) => {
    if (action.payload instanceof Observable) {
        const /** @type {?} */ baseType = action.type;
        let /** @type {?} */ obs = action.payload;
        if (action.meta && action.meta["cancel"]) {
            // if the action has a cancel observable, use it
            obs = obs.takeUntil(action.meta["cancel"]);
        }
        store.dispatch({
            type: `${baseType}_START`,
            meta: action.meta,
        });
        obs.subscribe((data) => store.dispatch({
            type: `${baseType}_NEXT`,
            payload: data,
            meta: action.meta,
        }), (error) => store.dispatch({
            type: `${baseType}_ERROR`,
            payload: error,
            meta: action.meta,
        }), () => {
            if (action.meta && action.meta["dispatchCompleted"]) {
                store.dispatch({ type: `${baseType}_COMPLETED` });
            }
        });
    }
    else {
        return next(action);
    }
};
/**
 * Wrapper around redux-logger middleware to work with ImmutableJS data structures
 */
const loggerMiddleware = createLogger({
    stateTransformer: (state) => (state.toJS ? state.toJS() : state),
});
/**
 * Simple middleware to stop actions with an empty type from reaching the rest of the redux logic.
 *
 * @param store
 */
const removeEmptyActionsMiddleware = (_) => (next) => (action) => {
    if (action && action.type) {
        return next(action);
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for an Angular Root Module.
 *
 * This sets up all the basics like redux store, stable tracking, hmr in dev ...
 *
 * @export
 * @abstract
 * @abstract
 */
class MainBaseModule {
    /**
     * @param {?} store
     * @param {?} devTools
     * @param {?} rootReducer
     * @param {?} rootEpic
     * @param {?} ngReduxRouter
     * @param {?} environment
     * @param {?} stableService
     */
    constructor(store, devTools, rootReducer, rootEpic, ngReduxRouter, environment, stableService) {
        this.store = store;
        this.devTools = devTools;
        this.rootReducer = rootReducer;
        this.rootEpic = rootEpic;
        this.ngReduxRouter = ngReduxRouter;
        this.environment = environment;
        this.stableService = stableService;
        let /** @type {?} */ appState;
        // @ts-ignore
        if (module.hot && window.hmrData) {
            // @ts-ignore
            appState = window.hmrData.appState;
            // @ts-ignore
            delete window.hmrData;
        }
        this.setupStore(appState);
        this.ngReduxRouter.initialize(routerStateSelector);
    }
    /**
     * @param {?=} appState
     * @return {?}
     */
    setupStore(appState = Map({})) {
        const /** @type {?} */ store = createReduxStore(/** @type {?} */ (this.rootReducer.reducer()), fromJS(appState), this.getMiddleware(), this.getEnhancers());
        this.store.provideStore(store);
        this.stableService.init();
    }
    /**
     * @return {?}
     */
    getMiddleware() {
        let /** @type {?} */ defaultMiddleware = [
            removeEmptyActionsMiddleware,
            observableMiddleware,
            this.rootEpic.middleware,
        ];
        if (this.environment.additionalMiddleware) {
            defaultMiddleware = [
                ...defaultMiddleware,
                ...this.environment.additionalMiddleware,
            ];
        }
        return defaultMiddleware;
    }
    /**
     * @return {?}
     */
    getEnhancers() {
        let /** @type {?} */ defaultEnhancers = [];
        if (this.environment.additionalEnhancers) {
            defaultEnhancers = [
                ...defaultEnhancers,
                ...this.environment.additionalEnhancers,
            ];
        }
        if (!this.environment.production && this.devTools.isEnabled()) {
            defaultEnhancers = [...defaultEnhancers, this.devTools.enhancer()];
        }
        return defaultEnhancers;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const APP_REDUCERS = new InjectionToken('APP_REDUCERS');
const APP_EPICS = new InjectionToken('APP_EPICS');
const APP_ERROR_FORMATTERS = new InjectionToken('APP_ERROR_FORMATTERS');
const APP_TRANSLATIONS = new InjectionToken('APP_TRANSLATIONS');
const APP_ENVIRONMENT = new InjectionToken('APP_ENVIRONMENT');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const TRANSLATE_SET_LOCALE = 'TRANSLATE_SET_LOCALE';
class TranslateActions {
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        return {
            type: TRANSLATE_SET_LOCALE,
            payload: locale
        };
    }
}
TranslateActions.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TranslateActions.ctorParameters = () => [];
__decorate([
    dispatch(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Object)
], TranslateActions.prototype, "setLocale", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LocaleService {
    /**
     * @param {?} translateActions
     * @param {?} translateService
     */
    constructor(translateActions, translateService) {
        this.translateActions = translateActions;
        this.translateService = translateService;
    }
    /**
     * @return {?}
     */
    setup() {
        this.translateService.onLangChange.subscribe((event) => {
            this.translateActions.setLocale(event.lang);
        });
    }
}
LocaleService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LocaleService.ctorParameters = () => [
    { type: TranslateActions, },
    { type: TranslateService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ɵ0 = { name: 'en', translations: {} };
class AppTranslateModule {
    /**
     * @param {?} translate
     * @param {?} appLocale
     * @param {?} translations
     */
    constructor(translate, appLocale, translations) {
        this.translate = translate;
        this.appLocale = appLocale;
        this.translations = translations;
        this.setupTranslations();
    }
    /**
     * @return {?}
     */
    setupTranslations() {
        this.translations.forEach((translation) => {
            this.translate.setTranslation(translation.name, translation.translations, true);
        });
        this.translate.setDefaultLang(this.appLocale);
        this.translate.use(this.appLocale);
    }
}
AppTranslateModule.decorators = [
    { type: NgModule, args: [{
                exports: [TranslateModule],
                imports: [TranslateModule.forRoot()],
                providers: [
                    TranslateActions,
                    LocaleService,
                    { provide: APP_TRANSLATIONS, useValue: ɵ0, multi: true }
                ]
            },] },
];
/** @nocollapse */
AppTranslateModule.ctorParameters = () => [
    { type: TranslateService, },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
    { type: Array, decorators: [{ type: Inject, args: [APP_TRANSLATIONS,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wrapper class around Angular [[Http]].
 *
 * Adds features like schema validation, normalizing data, base API URL,
 * tracking the number of active requests ...
 *
 * @export
 */
class RestService {
    /**
     * @param {?} http
     * @param {?} environment
     */
    constructor(http, environment) {
        this.http = http;
        this.environment = environment;
        // tslint:disable-next-line:variable-name
        this._activeRequests = 0;
    }
    /**
     * @return {?}
     */
    get activeRequests() {
        return this._activeRequests;
    }
    /**
     * @param {?} num
     * @return {?}
     */
    set activeRequests(num) {
        this._activeRequests = num;
    }
    /**
     * HTTP GET
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    get(path, options = {}, schema, jsonSchemaValidator) {
        return this.request('get', path, options, schema, jsonSchemaValidator);
    }
    /**
     * HTTP POST
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?} body
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    post(path, body, options = {}, schema, jsonSchemaValidator) {
        options = Object.assign({}, options, { body });
        return this.request('post', path, options, schema, jsonSchemaValidator);
    }
    /**
     * HTTP PUT
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?} body
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    put(path, body, options = {}, schema, jsonSchemaValidator) {
        options = Object.assign({}, options, { body });
        return this.request('put', path, options, schema, jsonSchemaValidator);
    }
    /**
     * HTTP DELETE
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    delete(path, options = {}, schema, jsonSchemaValidator) {
        return this.request('delete', path, options, schema, jsonSchemaValidator);
    }
    /**
     * Base method called by the other get/post... methods
     *
     * @protected
     * \@memberof RestService
     * @param {?} type
     * @param {?} path
     * @param {?} requestOptions
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    request(type, path, requestOptions, schema, jsonSchemaValidator) {
        const /** @type {?} */ url = this.getUrl(path);
        requestOptions = this.buildRequestOptions(requestOptions);
        this.activeRequests++;
        return this.http
            .request(type, url, requestOptions)
            .map((data) => {
            if (jsonSchemaValidator) {
                const /** @type {?} */ valid = jsonSchemaValidator(data);
                if (!valid) {
                    this.logSchemaErrors(jsonSchemaValidator.errors, data, path, requestOptions);
                    if (this.environment.throwOnSchemaError) {
                        throw new Error('Schema validation failed');
                    }
                }
            }
            return data;
        })
            .map((data) => this.normalizePayload(data, schema))
            .map((data) => {
            this.activeRequests--;
            return data;
        })
            .catch((error) => {
            this.activeRequests--;
            throw error;
        })
            .share();
    }
    /**
     * @param {?} errors
     * @param {?} responseData
     * @param {?} path
     * @param {?} requestOptions
     * @return {?}
     */
    logSchemaErrors(errors, responseData, path, requestOptions) {
        if (errors && errors.length) {
            const /** @type {?} */ css = 'color: red; background-color: #ffe6e6; border: 1px solid #ff9999; padding: 1px 10px';
            console.group('%cSchema validation failed', css);
            console.log('Request:', path, requestOptions);
            console.log('Response Data:', responseData);
            console.group('%cErrors:', css);
            errors.forEach(error => {
                console.log(error);
            });
            console.groupEnd();
            console.groupEnd();
        }
    }
    /**
     * @param {?} path
     * @return {?}
     */
    getUrl(path) {
        let /** @type {?} */ url;
        if (path.startsWith('http') || path.startsWith('//')) {
            url = path;
        }
        else {
            url = `${this.environment.apiUrl}/${path}`;
        }
        return url;
    }
    /**
     * If a normalizr schema is given, it returns the normlaized date, the original data otherwise.
     *
     * @param {?} data
     * @param {?=} schema
     * @return {?} either normalized or the given data.
     */
    normalizePayload(data, schema) {
        if (schema) {
            return normalize(data, schema);
        }
        return data;
    }
    /**
     * Extracts the JSON from an Angular [[Response]]
     *
     * @param {?} response
     * @return {?} Whatever the HTTP call returned as JSON
     */
    extractResponseData(response) {
        let /** @type {?} */ payload;
        try {
            payload = response.json();
        }
        catch (/** @type {?} */ e) {
            payload = {};
        }
        return payload;
    }
    /**
     * Hook to do some processing of the given options
     *
     * Used mainly to add headers (like auth) or other default options to all requests.
     * Just returns the given options as default
     *
     * @param {?} options
     * @return {?}
     */
    buildRequestOptions(options) {
        return options;
    }
}
RestService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RestService.ctorParameters = () => [
    { type: HttpClient, },
    { type: undefined, decorators: [{ type: Inject, args: [APP_ENVIRONMENT,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Angular Service to inform the application wether the state is currently stable.
 *
 * Stable is defined currently by not having any open HTTP requests and no store updates.
 */
class StableService {
    /**
     * @param {?} http
     * @param {?} store
     */
    constructor(http, store) {
        this.http = http;
        this.store = store;
        this.onStoreStable$ = new BehaviorSubject(false);
        this.storeStable$ = this.onStoreStable$.distinctUntilChanged();
    }
    /**
     * @return {?}
     */
    init() {
        this.store.subscribe(() => {
            window.storeStable = false;
            this.onStoreStable$.next(false);
            if (this.http.activeRequests === 0) {
                window.storeStable = true;
                this.onStoreStable$.next(true);
            }
        });
    }
}
StableService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
StableService.ctorParameters = () => [
    { type: RestService, },
    { type: NgRedux, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class that builds the root reducer for redux from all injected [[APP_REDUCERS]].
 *
 * @export
 */
class RootReducer {
    /**
     * @param {?} reducerConfigs
     */
    constructor(reducerConfigs) {
        this.reducerConfigs = reducerConfigs;
        this.currentReducers = {};
    }
    /**
     *
     *
     * \@memberof RootReducer
     * @param {?=} newReducerConfigs
     * @return {?}
     */
    reducer(newReducerConfigs) {
        return /** @type {?} */ (enableBatching(combineReducers(this.buildReducers(newReducerConfigs))));
    }
    /**
     * Builds the root reducer.
     *
     * \@memberof RootReducer
     * @param {?=} newReducerConfigs
     * @return {?}
     */
    buildReducers(newReducerConfigs) {
        const /** @type {?} */ currentReducers = Object.assign({}, this.currentReducers);
        const /** @type {?} */ reducerConfigs = newReducerConfigs
            ? newReducerConfigs
            : this.reducerConfigs;
        this.currentReducers = reducerConfigs.reduce((r, config) => {
            if (typeof (/** @type {?} */ (config.reducer)).reducer === 'function') {
                r[config.name] = (/** @type {?} */ (config.reducer)).reducer();
            }
            else {
                r[config.name] = config.reducer;
            }
            return r;
        }, currentReducers);
        return this.currentReducers;
    }
}
RootReducer.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RootReducer.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [APP_REDUCERS,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} action$
 * @return {?}
 */
function dummyEpic(action$) {
    return action$.mergeMap(() => {
        return Observable.empty();
    });
}
/**
 * Wrapper class to activate all injected [[Epic]] instances and forward them to the redux-observable middleware.
 *
 * @export
 */
class RootEpic {
    /**
     * @param {?} epicConfigs
     */
    constructor(epicConfigs) {
        this.epicConfigs = epicConfigs;
        const /** @type {?} */ epics = this.buildEpics(epicConfigs);
        this.middleware = createEpicMiddleware(combineEpics(...epics));
    }
    /**
     * Returns the Root Epic given to the middleware
     *
     * \@memberof RootEpic
     * @return {?}
     */
    epic() {
        return combineEpics(...this.epicConfigs);
    }
    /**
     * This method collects the [[Epic]] functions from the injected APP_EPICS and extracts the function
     * from [[IEpicClass]] if given.
     *
     * @protected
     * \@memberof RootEpic
     * @param {?} epicConfigs
     * @return {?}
     */
    buildEpics(epicConfigs) {
        return epicConfigs.map(config => {
            if ((/** @type {?} */ (config)).epic) {
                return (/** @type {?} */ (config)).epic();
            }
            else {
                return /** @type {?} */ (config);
            }
        });
    }
}
RootEpic.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RootEpic.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [APP_EPICS,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ɵ0$1 = { name: 'router', reducer: routerReducer };
const ɵ1 = dummyEpic;
class ReduxModule {
}
ReduxModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    RootReducer,
                    RootEpic,
                    {
                        multi: true,
                        provide: APP_REDUCERS,
                        useValue: ɵ0$1,
                    },
                    { provide: APP_EPICS, useValue: ɵ1, multi: true },
                ],
            },] },
];
/** @nocollapse */
ReduxModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxUtilsModule {
}
NgxUtilsModule.decorators = [
    { type: NgModule, args: [{
                imports: [AppTranslateModule, ReduxModule],
                exports: [AppTranslateModule, ReduxModule],
                providers: [StableService, RestService]
            },] },
];
/** @nocollapse */
NgxUtilsModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function random() {
    return 42;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * Generates action names via naming convention based on [[observableMiddleware]].
 *
 * With the given baseName 'PRODUCT' it returns the object
 * ```
 * {
 *   base:  'PRODUCT',
 *   start: 'PRODUCT_START',
 *   next:  'PRODUCT_NEXT',
 *   error: 'PRODUCT_ERROR'
 * }
 * ```
 *
 * @export
 * @param {?} baseName
 * @return {?}
 */
function generateAsyncActionNames(baseName) {
    return {
        base: baseName,
        start: baseName + '_START',
        next: baseName + '_NEXT',
        error: baseName + '_ERROR',
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * Small wrapper around Immutable.fromJS, that sets correct typings.
 *
 * Using this method we can create a [[Map]] that will typecheck keys
 * and forbids adding new keys.
 * @template T
 * @param {?} o
 * @return {?}
 */
function createImmutableState(o) {
    return /** @type {?} */ (fromJS(o));
}
/**
 * Returns the merge result of the given state and the diff, while ensuring diff is an immutable before merge.
 *
 * @template T, D
 * @param {?} state
 * @param {?} diff
 * @return {?}
 */
function mergeState(state, diff) {
    return state.merge(fromJS(diff));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function createNormalizedEntityState() {
    return createImmutableState({
        result: '',
        entities: /** @type {?} */ (Map()),
        loading: false,
        loaded: false,
        updating: false,
        updatedAt: 0,
        error: null,
    });
}
/**
 * This creates a reducer with full CRUD functionality for a single entity.
 *
 * Requirement: Data received from API is normalized, see https://github.com/paularmstrong/normalizr
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @param {?=} customReducers
 * @return {?}
 */
function normalizedEntityReducerFactory(entityName, namespace, customReducers) {
    const /** @type {?} */ initialState = createNormalizedEntityState();
    return function (state = initialState, action) {
        const /** @type {?} */ actionNames = generateCrudActionNames(entityName, namespace);
        const /** @type {?} */ defaultReducers = {
            [actionNames.readOneStart]: (s, a) => {
                return mergeState(initialState, { loading: true });
            },
            [actionNames.readOneNext]: (s, a) => {
                return mergeState(s, {
                    loading: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            },
            [actionNames.readOneError]: (s, a) => {
                return mergeState(initialState, {
                    error: a.payload,
                });
            },
            [actionNames.createStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.createNext]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            },
            [actionNames.createError]: (s, a) => {
                return mergeState(initialState, { updating: false, error: a.payload });
            },
            [actionNames.updateStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.updateNext]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            },
            [actionNames.updateError]: (s, a) => {
                return mergeState(s, { updating: false, error: a.payload });
            },
            [actionNames.deleteStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.deleteNext]: (s, a) => {
                return initialState;
            },
            [actionNames.deleteError]: (s, a) => {
                return mergeState(s, { updating: false, error: a.payload });
            },
            [actionNames.setCurrent]: (s, a) => {
                return mergeState(initialState, {
                    loaded: true,
                    entities: fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            },
            [actionNames.reset]: (s, a) => {
                return initialState;
            },
            [actionNames.resetError]: (s, a) => {
                return s.set('error', null);
            },
        };
        const /** @type {?} */ reducers = Object.assign({}, defaultReducers, customReducers);
        if (reducers[action.type]) {
            return reducers[action.type](state, action);
        }
        return state;
    };
}
/**
 * @return {?}
 */
function createNormalizedCollectionState() {
    return createImmutableState({
        result: /** @type {?} */ ([]),
        entities: /** @type {?} */ ({}),
        loading: false,
        loaded: false,
        updating: false,
        updatedAt: 0,
        error: null,
    });
}
/**
 * This creates a reducer with full CRUD functionality for a collection of entities.
 *
 * Requirement: Data received from API is normalized, see https://github.com/paularmstrong/normalizr
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @param {?=} customReducers
 * @return {?}
 */
function normalizedCollectionReducerFactory(entityName, namespace, customReducers) {
    const /** @type {?} */ initialState = createNormalizedCollectionState();
    return function (state = initialState, action) {
        const /** @type {?} */ actionNames = generateCrudActionNames(entityName, namespace);
        const /** @type {?} */ defaultReducers = {
            [actionNames.readStart]: (s, a) => {
                return mergeState(initialState, { loading: true });
            },
            [actionNames.readNext]: (s, a) => {
                return mergeState(s, {
                    loading: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: fromJS(action.payload.entities),
                    result: action.payload.result,
                });
            },
            [actionNames.readError]: (s, a) => {
                return mergeState(initialState, { error: a.payload });
            },
            [actionNames.createStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.createNext]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').mergeDeep(fromJS(a.payload.entities)),
                    result: s.get('result').push(a.payload.result),
                });
            },
            [actionNames.createError]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            },
            [actionNames.updateStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.updateNext]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').mergeDeep(fromJS(a.payload.entities)),
                });
            },
            [actionNames.updateError]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            },
            [actionNames.deleteStart]: (s, a) => {
                return mergeState(s, { updating: true, error: null });
            },
            [actionNames.deleteNext]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').deleteIn([entityName, a.payload.result]),
                    result: s
                        .get('result')
                        .update(ids => ids.filterNot(id => id === a.payload.result)),
                });
            },
            [actionNames.deleteError]: (s, a) => {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            },
            [actionNames.reset]: (s, a) => {
                return initialState;
            },
            [actionNames.resetError]: (s, a) => {
                return s.set('error', null);
            },
        };
        const /** @type {?} */ reducers = Object.assign({}, defaultReducers, customReducers);
        if (reducers[action.type]) {
            return reducers[action.type](state, action);
        }
        return state;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Small wrapper around reselect [[createSelector]], that knows how to compare ImmutableJS data structures.
 */
const createSelector = createSelectorCreator(defaultMemoize, is);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Creates selectors for a reducer based on a [[INormalizedEntityState]].
 *
 * Provides base selectors for all attributes and also for building a [[Record]] instance out of the raw data
 *
 * @export
 * @template T
 * @param {?} entityName
 * @param {?} entityClass The [[Record.Class]] class to build the model from
 * @param {?} schema The same schema that was used no normalize the data in the first place
 * @param {?=} customSelectors
 * @return {?}
 */
function normalizedEntitySelectorFactory(entityName, entityClass, schema, customSelectors = {}) {
    const /** @type {?} */ baseSelector = (state) => state.get(entityName);
    const /** @type {?} */ idSelector = (state) => baseSelector(state).get('result');
    const /** @type {?} */ entitiesSelector = (state) => baseSelector(state).get('entities');
    const /** @type {?} */ modelSelector = createSelector([idSelector, entitiesSelector], (id, entities) => {
        if (id) {
            const /** @type {?} */ denormalizedData = denormalize(id, schema, entities);
            return new entityClass(denormalizedData);
        }
        else {
            return new entityClass();
        }
    });
    return Object.assign({}, {
        subStateSelector: baseSelector,
        loadingSelector: (state) => baseSelector(state).get('loading'),
        loadedSelector: (state) => baseSelector(state).get('loaded'),
        updatingSelector: (state) => baseSelector(state).get('updating'),
        updatedAtSelector: (state) => baseSelector(state).get('updatedAt'),
        idSelector,
        modelSelector,
    }, customSelectors);
}
/**
 * Creates selectors for a reducer based on a [[INormalizedCollectionState]].
 *
 * Provides base selectors for all attributes and also for building a collection of [[Record]] instances out of the raw data
 *
 * @export
 * @template T
 * @param {?} entityName
 * @param {?} entityClass The [[Record.Class]] class to build the models from
 * @param {?} schema The same schema that was used no normalize the data in the first place
 * @param {?=} customSelectors
 * @return {?}
 */
function normalizedCollectionSelectorsFactory(entityName, entityClass, schema, customSelectors = {}) {
    const /** @type {?} */ baseSelector = (state) => state.get(entityName);
    const /** @type {?} */ idsSelector = (state) => baseSelector(state).get('result');
    const /** @type {?} */ entitiesSelector = (state) => baseSelector(state).get('entities');
    const /** @type {?} */ modelsSelector = createSelector([idsSelector, entitiesSelector], (ids, entities) => {
        const /** @type {?} */ denormalizedData = denormalize(ids, schema, entities);
        return denormalizedData.map((item) => new entityClass(item));
    });
    const /** @type {?} */ modelsMapSelector = createSelector([modelsSelector], models => {
        return models.reduce((acc, item) => {
            return acc.set(String(item.get('id', null)), item);
        }, Map());
    });
    return Object.assign({}, {
        subStateSelector: baseSelector,
        loadingSelector: (state) => baseSelector(state).get('loading'),
        loadedSelector: (state) => baseSelector(state).get('loaded'),
        updatingSelector: (state) => baseSelector(state).get('updating'),
        updatedAtSelector: (state) => baseSelector(state).get('updatedAt'),
        idsSelector,
        modelsSelector,
        modelsMapSelector,
    }, customSelectors);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for Environment settings.
 *
 * Subclass this to add a real Environment to your app.
 *
 * @export
 * @abstract
 * @abstract
 */
class DefaultEnvironment {
    constructor() {
        this.production = false;
        /**
         * Base API URL for current Environment, used by [[RestService]]
         *
         * \@memberof DefaultEnvironment
         */
        this.apiUrl = '';
        /**
         * Thow if a given JSON Schema produces a validation error on data?
         *
         * \@memberof DefaultEnvironment
         */
        this.throwOnSchemaError = true;
        /**
         * Ask user for confirmation to relaod the page after a ServiceWorker update?
         *
         * \@memberof DefaultEnvironment
         */
        this.autoUpdate = 'always';
        this.updateMessage = 'A new version of the app is available. Do you want to reload the page to update?';
        /**
         * HTML <title> tag
         *
         * \@memberof DefaultEnvironment
         */
        this.pageTitle = 'DCS Angular Starter';
        /**
         * What to set as <base href>
         *
         * see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
         *
         * \@memberof DefaultEnvironment
         */
        this.base = '/';
        /**
         * Add app specific redux enhancers here.
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalEnhancers = [];
        /**
         * Add app specific middleware here.
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalMiddleware = [];
        /**
         * Add here, whatever additional settings your app needs
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalSettings = {};
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DefaultErrorHandler {
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        // clean up potential broken persisted state if an error bubbles up to the global handler
        localStorage.clear();
        throw error;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Given a JSON schema, this compiles a validator function to use later
 *
 * Basically a small wrapper around [[Ajv]]
 *
 * @export
 * @param {?} jsonSchema
 * @param {?=} ajv
 * @return {?}
 */
function buildSchemaValidator(jsonSchema, ajv) {
    if (!ajv) {
        ajv = new Ajv({ allErrors: true });
    }
    return ajv.compile(jsonSchema);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} recordClass
 * @return {?}
 */
function EmbeddedRecord(recordClass) {
    return function (target, key) {
        const /** @type {?} */ cache = new WeakMap();
        return {
            /**
             * @return {?}
             */
            get() {
                if (!cache.has(this)) {
                    cache.set(this, new recordClass(this.get(key)));
                }
                return cache.get(this);
            }
        };
    };
}
/**
 * @param {?} recordClass
 * @param {?=} collectionFactory
 * @return {?}
 */
function EmbeddedCollection(recordClass, collectionFactory = List) {
    return function (target, key) {
        const /** @type {?} */ cache = new WeakMap();
        return {
            /**
             * @return {?}
             */
            get() {
                if (!cache.has(this)) {
                    const /** @type {?} */ collection = this.get(key) || collectionFactory();
                    cache.set(this, collectionFactory(collection.map((data) => new recordClass(data))));
                }
                return cache.get(this);
            }
        };
    };
}
/**
 * @template TBase
 * @param {?} Base
 * @return {?}
 */
function ExtendedRecord(Base) {
    return class extends Base {
        /**
         * @param {...?} args
         */
        constructor(...args) {
            const /** @type {?} */ params = fromJS(args.shift());
            super(params, ...args);
        }
        /**
         * @param {?} params
         * @return {?}
         */
        with(params) {
            return /** @type {?} */ (this.merge(fromJS(params)));
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} c
 * @return {?}
 */
function validateEmail(c) {
    return isEmail(String(c.value)) ? null : { validateEmail: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validatePhone(c) {
    return isMobilePhone(String(c.value), 'de-DE')
        ? null
        : { validatePhone: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateFQDN(c) {
    return isFQDN(String(c.value)) ? null : { validateFQDN: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validatePositiveInteger(c) {
    const /** @type {?} */ value = String(c.value);
    return isInt(value, { min: 1 })
        ? null
        : { validatePositiveInteger: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateDate(c) {
    const /** @type {?} */ value = parse(c.value, 'YYYY-MM-DD', 0);
    return isValid(value) ? null : { validateDate: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateTime(c) {
    const /** @type {?} */ value = parse(c.value, 'HH:mm', 0);
    return isValid(value) ? null : { validateTime: { valid: false } };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { MainBaseModule, NgxUtilsModule, RestService, StableService, AppTranslateModule, LocaleService, TranslateActions, ContainerComponent, PresentationalComponent, random, ReduxModule, RootEpic, dummyEpic, RootReducer, generateAsyncActionNames, observableMiddleware, loggerMiddleware, removeEmptyActionsMiddleware, createNormalizedEntityState, normalizedEntityReducerFactory, createNormalizedCollectionState, normalizedCollectionReducerFactory, normalizedEntitySelectorFactory, normalizedCollectionSelectorsFactory, generateCrudActionNames, subStateStale, hasModel, createImmutableState, mergeState, createSelector, createReduxStore, persistStateEnhancer, routerStateSelector, APP_REDUCERS, APP_EPICS, APP_ERROR_FORMATTERS, APP_TRANSLATIONS, APP_ENVIRONMENT, DefaultEnvironment, DefaultErrorHandler, buildSchemaValidator, EmbeddedRecord, EmbeddedCollection, ExtendedRecord, validateEmail, validatePhone, validateFQDN, validatePositiveInteger, validateDate, validateTime };
//# sourceMappingURL=dcs-ngx-utils.js.map
