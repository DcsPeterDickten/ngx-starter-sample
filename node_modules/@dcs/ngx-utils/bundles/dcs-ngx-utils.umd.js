(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/add/operator/first'), require('redux'), require('immutable'), require('redux-localstorage'), require('transit-immutable-js'), require('redux-logger'), require('rxjs/Observable'), require('rxjs/add/operator/takeUntil'), require('@angular-redux/store'), require('@ngx-translate/core'), require('@angular/common/http'), require('normalizr'), require('rxjs/add/operator/catch'), require('rxjs/add/operator/map'), require('rxjs/add/operator/share'), require('rxjs/BehaviorSubject'), require('rxjs/add/operator/distinctUntilChanged'), require('redux-immutable'), require('redux-batched-actions'), require('redux-observable'), require('rxjs/add/operator/mergeMap'), require('rxjs/add/observable/empty'), require('@angular-redux/router'), require('reselect'), require('ajv'), require('validator'), require('date-fns')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/add/operator/first', 'redux', 'immutable', 'redux-localstorage', 'transit-immutable-js', 'redux-logger', 'rxjs/Observable', 'rxjs/add/operator/takeUntil', '@angular-redux/store', '@ngx-translate/core', '@angular/common/http', 'normalizr', 'rxjs/add/operator/catch', 'rxjs/add/operator/map', 'rxjs/add/operator/share', 'rxjs/BehaviorSubject', 'rxjs/add/operator/distinctUntilChanged', 'redux-immutable', 'redux-batched-actions', 'redux-observable', 'rxjs/add/operator/mergeMap', 'rxjs/add/observable/empty', '@angular-redux/router', 'reselect', 'ajv', 'validator', 'date-fns'], factory) :
	(factory((global.dcs = global.dcs || {}, global.dcs['ngx-utils'] = {}),global.ng.core,global.Rx.Observable.prototype,global.Redux,global.Immutable,global.persistState,global.transit,global.reduxLogger,global.Rx,global.Rx.Observable.prototype,global.store,global.core$1,global.ng.common.http,global.normalizr,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx,global.Rx.Observable.prototype,global.reduxImmutable,global.reduxBatchedActions,global.reduxObservable,global.Rx.Observable.prototype,global.Rx.Observable,global.router,global.reselect,global.Ajv,global.validator,global.DateFns));
}(this, (function (exports,core,first,redux,immutable,persistState,transit,reduxLogger,Observable,takeUntil,store,core$1,http,normalizr,_catch,map,share,BehaviorSubject,distinctUntilChanged,reduxImmutable,reduxBatchedActions,reduxObservable,mergeMap,empty,router,reselect,Ajv,validator,dateFns) { 'use strict';

persistState = persistState && persistState.hasOwnProperty('default') ? persistState['default'] : persistState;
transit = transit && transit.hasOwnProperty('default') ? transit['default'] : transit;
Ajv = Ajv && Ajv.hasOwnProperty('default') ? Ajv['default'] : Ajv;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}


function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}




function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generate standardized action names, used mainly for the normalized reducers.
 *
 * For all the CRUD actions all 4 actions (base, start, next, error) are created.
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @return {?}
 */
function generateCrudActionNames(entityName, namespace) {
    var /** @type {?} */ BASE_NAME = namespace
        ? namespace.toLocaleUpperCase() + "_" + entityName.toLocaleUpperCase()
        : entityName.toLocaleUpperCase();
    var /** @type {?} */ START = 'START';
    var /** @type {?} */ NEXT = 'NEXT';
    var /** @type {?} */ ERROR = 'ERROR';
    var /** @type {?} */ READ = BASE_NAME + "_READ";
    var /** @type {?} */ READ_ONE = BASE_NAME + "_READ_ONE";
    var /** @type {?} */ CREATE = BASE_NAME + "_CREATE";
    var /** @type {?} */ UPDATE = BASE_NAME + "_UPDATE";
    var /** @type {?} */ DELETE = BASE_NAME + "_DELETE";
    return {
        read: READ,
        readStart: READ + "_" + START,
        readNext: READ + "_" + NEXT,
        readNextUpdate: READ + "_" + NEXT + "_UPDATE",
        readError: READ + "_" + ERROR,
        readOne: READ_ONE,
        readOneStart: READ_ONE + "_" + START,
        readOneNext: READ_ONE + "_" + NEXT,
        readOneNextUpdate: READ_ONE + "_" + NEXT + "_UPDATE",
        readOneError: READ_ONE + "_" + ERROR,
        create: CREATE,
        createStart: CREATE + "_" + START,
        createNext: CREATE + "_" + NEXT,
        createError: CREATE + "_" + ERROR,
        update: UPDATE,
        updateStart: UPDATE + "_" + START,
        updateNext: UPDATE + "_" + NEXT,
        updateError: UPDATE + "_" + ERROR,
        delete: DELETE,
        deleteStart: DELETE + "_" + START,
        deleteNext: DELETE + "_" + NEXT,
        deleteError: DELETE + "_" + ERROR,
        setCurrent: BASE_NAME + "_SET_CURRENT",
        reset: BASE_NAME + "_RESET",
        resetError: BASE_NAME + "_RESET_ERROR",
    };
}
/**
 * Tests if a normalized subState has data that is too old.
 *
 * Given the maxAge, it tests if the data is already loaded and not older than maxAge.
 *
 * @export
 * @param {?} state
 * @param {?=} maxAge
 * @return {?}
 */
function subStateStale(state, maxAge) {
    if (maxAge === void 0) { maxAge = 0; }
    var /** @type {?} */ updatedAt = state.get('updatedAt');
    return updatedAt === 0 || Date.now() - updatedAt - maxAge > 0;
}
/**
 * Tests if a normalized state has a specific model instace
 *
 * @export
 * @param {?} collectionSubState the given state
 * @param {?} entitiesName the name of the collection in entities
 * @param {?} id the id of the model instance to fetch
 * @param {?=} maxAge
 * @return {?}
 */
function hasModel(collectionSubState, entitiesName, id, maxAge) {
    id = String(id);
    if (maxAge) {
        var /** @type {?} */ updatedAt = collectionSubState.get('updatedAt');
        var /** @type {?} */ dataCurrent = Date.now() - updatedAt - maxAge < 0;
        if (!dataCurrent) {
            return false;
        }
    }
    return collectionSubState.hasIn(['entities', entitiesName, id]);
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for smart/container Components.
 *
 * This is used for Components with store data access.
 *
 * @export
 */
var ContainerComponent = /** @class */ (function () {
    function ContainerComponent() {
        this.subscriptions = [];
    }
    /**
     * Default OnDestroy callback that unsubscribes from all rxjs Subscriptions of this component.
     *
     * \@memberof ContainerComponent
     * @return {?}
     */
    ContainerComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (subscription) {
            subscription.unsubscribe();
        });
        this.subscriptions = [];
    };
    /**
     * Wrapper around [[Observable.subscribe]] that saves the [[Subscription]] to be removed later.
     *
     * \@memberof ContainerComponent
     * @template T
     * @param {?} obs
     * @param {?} callback
     * @return {?}
     */
    ContainerComponent.prototype.subscribeToObservable = function (obs, callback) {
        this.subscriptions.push(obs.subscribe(callback.bind(this)));
    };
    /**
     * Shortcut function to always have the current value from an [[Observable]] available in the [[Component]]
     *
     * \@memberof ContainerComponent
     * @template T
     * @param {?} obs The Observable to get the data from.
     * @param {?} propertyName The name of the property where to store the data in.
     * @return {?}
     */
    ContainerComponent.prototype.valueFromObservable = function (obs, propertyName) {
        var _this = this;
        this.subscribeToObservable(obs, function (data) {
            _this[propertyName] = data;
        });
    };
    /**
     * Helper function to execute a callback only, if a [[INormalizedCollectionState]] has stale data.
     *
     * Usually used to check if the data in a selector is too old and the dispatch the read data action.
     *
     * \@memberof ContainerComponent
     * @param {?} subState$
     * @param {?} maxAge
     * @param {?} callback
     * @return {?}
     */
    ContainerComponent.prototype.executeIfStateStale = function (subState$, maxAge, callback) {
        subState$.first().subscribe(function (subState) {
            if (subStateStale(subState, maxAge)) {
                callback();
            }
        });
    };
    return ContainerComponent;
}());
ContainerComponent.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
ContainerComponent.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for *dumb* components
 *
 * Data is transfered via Inputs and Outputs, no Store or Actions allowed.
 *
 * @export
 */
var PresentationalComponent = /** @class */ (function () {
    function PresentationalComponent() {
    }
    /**
     * ImmutableJS aware track function
     *
     * Mainly used in ngFor trackBy
     *
     * \@memberOf PresentationalComponent
     * @param {?} _
     * @param {?} item
     * @return {?}
     *
     */
    PresentationalComponent.prototype.identify = function (_, item) {
        if (typeof item.hashCode !== 'function') {
            throw new TypeError("Given item is not of type Immutable, " + item.toString() + " given!");
        }
        return item.hashCode();
    };
    /**
     * Tests, wether a form component has errors
     *
     * \@memberOf PresentationalComponent
     * @param {?} form
     * @param {?} fieldName
     * @param {?=} errorName
     * @return {?}
     *
     */
    PresentationalComponent.prototype.hasError = function (form, fieldName, errorName) {
        var /** @type {?} */ control = (form.get(fieldName));
        if (control.untouched) {
            return false;
        }
        if (errorName) {
            return !!(control.errors && control.errors[errorName]);
        }
        else {
            return !!control.errors;
        }
    };
    return PresentationalComponent;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Helper function to setup the redux store with reducers, middleware and enhancers.
 *
 * @export
 * @param {?} rootReducer
 * @param {?=} initialState
 * @param {?=} middleware
 * @param {?=} enhancers
 * @return {?}
 */
function createReduxStore(rootReducer, initialState, middleware, enhancers) {
    if (initialState === void 0) { initialState = immutable.fromJS({}); }
    if (middleware === void 0) { middleware = []; }
    if (enhancers === void 0) { enhancers = []; }
    return /** @type {?} */ (redux.createStore(rootReducer, initialState, redux.compose.apply(void 0, __spread([redux.applyMiddleware.apply(void 0, __spread(middleware))], enhancers))));
}
/**
 * Redux [[GenericStoreEnhancer]] that persists all state changes to localStorage,
 * knowing how to handle an ImmutableJS state.
 *
 * @export
 * @param {?=} paths
 * @return {?}
 */
function persistStateEnhancer(paths) {
    var /** @type {?} */ converter = transit.withFilter(function (value) {
        return !(value instanceof Error);
    });
    return persistState(paths, {
        serialize: function (state) { return converter.toJSON(state); },
        deserialize: function (data) { return converter.fromJSON(data); },
        merge: function (initialState, persistedState) { return initialState.merge(persistedState); },
        slicer: function (statePaths) {
            return function (state) {
                if (typeof statePaths === 'string') {
                    return state.filter(function (_, k) { return k === statePaths; });
                }
                else if (Array.isArray(statePaths)) {
                    return state.filter(function (_, k) { return statePaths.indexOf(k) !== -1; });
                }
                else {
                    return state;
                }
            };
        },
    });
}
/**
 * Selector function to return the current router substate.
 *
 * @export
 * @param {?} state
 * @return {?} string
 */
function routerStateSelector(state) {
    return state.get('router');
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Middleware to automatically dispatch async actions when getting an Observable as payload
 *
 * It dispatches a _START action at once,
 * a _NEXT action for every next tick with the result data of the next as payload
 * and a _ERROR action, should the Observable generate an exception.
 *
 * If the initial action includes an Observable in action.meta.cancel, this is used to cancel out the
 * _NEXT actions as soon as this one fires once.
 *
 * @param store
 * @param action
 */
var observableMiddleware = function (store$$1) { return function (next) { return function (action) {
    if (action.payload instanceof Observable.Observable) {
        var /** @type {?} */ baseType_1 = action.type;
        var /** @type {?} */ obs = action.payload;
        if (action.meta && action.meta["cancel"]) {
            // if the action has a cancel observable, use it
            obs = obs.takeUntil(action.meta["cancel"]);
        }
        store$$1.dispatch({
            type: baseType_1 + "_START",
            meta: action.meta,
        });
        obs.subscribe(function (data) { return store$$1.dispatch({
            type: baseType_1 + "_NEXT",
            payload: data,
            meta: action.meta,
        }); }, function (error) { return store$$1.dispatch({
            type: baseType_1 + "_ERROR",
            payload: error,
            meta: action.meta,
        }); }, function () {
            if (action.meta && action.meta["dispatchCompleted"]) {
                store$$1.dispatch({ type: baseType_1 + "_COMPLETED" });
            }
        });
    }
    else {
        return next(action);
    }
}; }; };
/**
 * Wrapper around redux-logger middleware to work with ImmutableJS data structures
 */
var loggerMiddleware = reduxLogger.createLogger({
    stateTransformer: function (state) { return (state.toJS ? state.toJS() : state); },
});
/**
 * Simple middleware to stop actions with an empty type from reaching the rest of the redux logic.
 *
 * @param store
 */
var removeEmptyActionsMiddleware = function (_) { return function (next) { return function (action) {
    if (action && action.type) {
        return next(action);
    }
}; }; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for an Angular Root Module.
 *
 * This sets up all the basics like redux store, stable tracking, hmr in dev ...
 *
 * @export
 * @abstract
 * @abstract
 */
var MainBaseModule = /** @class */ (function () {
    /**
     * @param {?} store
     * @param {?} devTools
     * @param {?} rootReducer
     * @param {?} rootEpic
     * @param {?} ngReduxRouter
     * @param {?} environment
     * @param {?} stableService
     */
    function MainBaseModule(store$$1, devTools, rootReducer, rootEpic, ngReduxRouter, environment, stableService) {
        this.store = store$$1;
        this.devTools = devTools;
        this.rootReducer = rootReducer;
        this.rootEpic = rootEpic;
        this.ngReduxRouter = ngReduxRouter;
        this.environment = environment;
        this.stableService = stableService;
        var /** @type {?} */ appState;
        // @ts-ignore
        if (module.hot && window.hmrData) {
            // @ts-ignore
            appState = window.hmrData.appState;
            // @ts-ignore
            delete window.hmrData;
        }
        this.setupStore(appState);
        this.ngReduxRouter.initialize(routerStateSelector);
    }
    /**
     * @param {?=} appState
     * @return {?}
     */
    MainBaseModule.prototype.setupStore = function (appState) {
        if (appState === void 0) { appState = immutable.Map({}); }
        var /** @type {?} */ store$$1 = createReduxStore(/** @type {?} */ (this.rootReducer.reducer()), immutable.fromJS(appState), this.getMiddleware(), this.getEnhancers());
        this.store.provideStore(store$$1);
        this.stableService.init();
    };
    /**
     * @return {?}
     */
    MainBaseModule.prototype.getMiddleware = function () {
        var /** @type {?} */ defaultMiddleware = [
            removeEmptyActionsMiddleware,
            observableMiddleware,
            this.rootEpic.middleware,
        ];
        if (this.environment.additionalMiddleware) {
            defaultMiddleware = __spread(defaultMiddleware, this.environment.additionalMiddleware);
        }
        return defaultMiddleware;
    };
    /**
     * @return {?}
     */
    MainBaseModule.prototype.getEnhancers = function () {
        var /** @type {?} */ defaultEnhancers = [];
        if (this.environment.additionalEnhancers) {
            defaultEnhancers = __spread(defaultEnhancers, this.environment.additionalEnhancers);
        }
        if (!this.environment.production && this.devTools.isEnabled()) {
            defaultEnhancers = __spread(defaultEnhancers, [this.devTools.enhancer()]);
        }
        return defaultEnhancers;
    };
    return MainBaseModule;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var APP_REDUCERS = new core.InjectionToken('APP_REDUCERS');
var APP_EPICS = new core.InjectionToken('APP_EPICS');
var APP_ERROR_FORMATTERS = new core.InjectionToken('APP_ERROR_FORMATTERS');
var APP_TRANSLATIONS = new core.InjectionToken('APP_TRANSLATIONS');
var APP_ENVIRONMENT = new core.InjectionToken('APP_ENVIRONMENT');
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TRANSLATE_SET_LOCALE = 'TRANSLATE_SET_LOCALE';
var TranslateActions = /** @class */ (function () {
    function TranslateActions() {
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    TranslateActions.prototype.setLocale = function (locale) {
        return {
            type: TRANSLATE_SET_LOCALE,
            payload: locale
        };
    };
    return TranslateActions;
}());
TranslateActions.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
TranslateActions.ctorParameters = function () { return []; };
__decorate([
    store.dispatch(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Object)
], TranslateActions.prototype, "setLocale", null);
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LocaleService = /** @class */ (function () {
    /**
     * @param {?} translateActions
     * @param {?} translateService
     */
    function LocaleService(translateActions, translateService) {
        this.translateActions = translateActions;
        this.translateService = translateService;
    }
    /**
     * @return {?}
     */
    LocaleService.prototype.setup = function () {
        var _this = this;
        this.translateService.onLangChange.subscribe(function (event) {
            _this.translateActions.setLocale(event.lang);
        });
    };
    return LocaleService;
}());
LocaleService.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
LocaleService.ctorParameters = function () { return [
    { type: TranslateActions, },
    { type: core$1.TranslateService, },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ɵ0 = { name: 'en', translations: {} };
var AppTranslateModule = /** @class */ (function () {
    /**
     * @param {?} translate
     * @param {?} appLocale
     * @param {?} translations
     */
    function AppTranslateModule(translate, appLocale, translations) {
        this.translate = translate;
        this.appLocale = appLocale;
        this.translations = translations;
        this.setupTranslations();
    }
    /**
     * @return {?}
     */
    AppTranslateModule.prototype.setupTranslations = function () {
        var _this = this;
        this.translations.forEach(function (translation) {
            _this.translate.setTranslation(translation.name, translation.translations, true);
        });
        this.translate.setDefaultLang(this.appLocale);
        this.translate.use(this.appLocale);
    };
    return AppTranslateModule;
}());
AppTranslateModule.decorators = [
    { type: core.NgModule, args: [{
                exports: [core$1.TranslateModule],
                imports: [core$1.TranslateModule.forRoot()],
                providers: [
                    TranslateActions,
                    LocaleService,
                    { provide: APP_TRANSLATIONS, useValue: ɵ0, multi: true }
                ]
            },] },
];
/** @nocollapse */
AppTranslateModule.ctorParameters = function () { return [
    { type: core$1.TranslateService, },
    { type: undefined, decorators: [{ type: core.Inject, args: [core.LOCALE_ID,] },] },
    { type: Array, decorators: [{ type: core.Inject, args: [APP_TRANSLATIONS,] },] },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wrapper class around Angular [[Http]].
 *
 * Adds features like schema validation, normalizing data, base API URL,
 * tracking the number of active requests ...
 *
 * @export
 */
var RestService = /** @class */ (function () {
    /**
     * @param {?} http
     * @param {?} environment
     */
    function RestService(http$$1, environment) {
        this.http = http$$1;
        this.environment = environment;
        // tslint:disable-next-line:variable-name
        this._activeRequests = 0;
    }
    Object.defineProperty(RestService.prototype, "activeRequests", {
        /**
         * @return {?}
         */
        get: function () {
            return this._activeRequests;
        },
        /**
         * @param {?} num
         * @return {?}
         */
        set: function (num) {
            this._activeRequests = num;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * HTTP GET
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    RestService.prototype.get = function (path, options, schema, jsonSchemaValidator) {
        if (options === void 0) { options = {}; }
        return this.request('get', path, options, schema, jsonSchemaValidator);
    };
    /**
     * HTTP POST
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?} body
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    RestService.prototype.post = function (path, body, options, schema, jsonSchemaValidator) {
        if (options === void 0) { options = {}; }
        options = Object.assign({}, options, { body: body });
        return this.request('post', path, options, schema, jsonSchemaValidator);
    };
    /**
     * HTTP PUT
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?} body
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    RestService.prototype.put = function (path, body, options, schema, jsonSchemaValidator) {
        if (options === void 0) { options = {}; }
        options = Object.assign({}, options, { body: body });
        return this.request('put', path, options, schema, jsonSchemaValidator);
    };
    /**
     * HTTP DELETE
     *
     * \@memberof RestService
     * @param {?} path
     * @param {?=} options
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    RestService.prototype.delete = function (path, options, schema, jsonSchemaValidator) {
        if (options === void 0) { options = {}; }
        return this.request('delete', path, options, schema, jsonSchemaValidator);
    };
    /**
     * Base method called by the other get/post... methods
     *
     * @protected
     * \@memberof RestService
     * @param {?} type
     * @param {?} path
     * @param {?} requestOptions
     * @param {?=} schema
     * @param {?=} jsonSchemaValidator
     * @return {?}
     */
    RestService.prototype.request = function (type, path, requestOptions, schema, jsonSchemaValidator) {
        var _this = this;
        var /** @type {?} */ url = this.getUrl(path);
        requestOptions = this.buildRequestOptions(requestOptions);
        this.activeRequests++;
        return this.http
            .request(type, url, requestOptions)
            .map(function (data) {
            if (jsonSchemaValidator) {
                var /** @type {?} */ valid = jsonSchemaValidator(data);
                if (!valid) {
                    _this.logSchemaErrors(jsonSchemaValidator.errors, data, path, requestOptions);
                    if (_this.environment.throwOnSchemaError) {
                        throw new Error('Schema validation failed');
                    }
                }
            }
            return data;
        })
            .map(function (data) { return _this.normalizePayload(data, schema); })
            .map(function (data) {
            _this.activeRequests--;
            return data;
        })
            .catch(function (error) {
            _this.activeRequests--;
            throw error;
        })
            .share();
    };
    /**
     * @param {?} errors
     * @param {?} responseData
     * @param {?} path
     * @param {?} requestOptions
     * @return {?}
     */
    RestService.prototype.logSchemaErrors = function (errors, responseData, path, requestOptions) {
        if (errors && errors.length) {
            var /** @type {?} */ css = 'color: red; background-color: #ffe6e6; border: 1px solid #ff9999; padding: 1px 10px';
            console.group('%cSchema validation failed', css);
            console.log('Request:', path, requestOptions);
            console.log('Response Data:', responseData);
            console.group('%cErrors:', css);
            errors.forEach(function (error) {
                console.log(error);
            });
            console.groupEnd();
            console.groupEnd();
        }
    };
    /**
     * @param {?} path
     * @return {?}
     */
    RestService.prototype.getUrl = function (path) {
        var /** @type {?} */ url;
        if (path.startsWith('http') || path.startsWith('//')) {
            url = path;
        }
        else {
            url = this.environment.apiUrl + "/" + path;
        }
        return url;
    };
    /**
     * If a normalizr schema is given, it returns the normlaized date, the original data otherwise.
     *
     * @param {?} data
     * @param {?=} schema
     * @return {?} either normalized or the given data.
     */
    RestService.prototype.normalizePayload = function (data, schema) {
        if (schema) {
            return normalizr.normalize(data, schema);
        }
        return data;
    };
    /**
     * Extracts the JSON from an Angular [[Response]]
     *
     * @param {?} response
     * @return {?} Whatever the HTTP call returned as JSON
     */
    RestService.prototype.extractResponseData = function (response) {
        var /** @type {?} */ payload;
        try {
            payload = response.json();
        }
        catch (e) {
            payload = {};
        }
        return payload;
    };
    /**
     * Hook to do some processing of the given options
     *
     * Used mainly to add headers (like auth) or other default options to all requests.
     * Just returns the given options as default
     *
     * @param {?} options
     * @return {?}
     */
    RestService.prototype.buildRequestOptions = function (options) {
        return options;
    };
    return RestService;
}());
RestService.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
RestService.ctorParameters = function () { return [
    { type: http.HttpClient, },
    { type: undefined, decorators: [{ type: core.Inject, args: [APP_ENVIRONMENT,] },] },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Angular Service to inform the application wether the state is currently stable.
 *
 * Stable is defined currently by not having any open HTTP requests and no store updates.
 */
var StableService = /** @class */ (function () {
    /**
     * @param {?} http
     * @param {?} store
     */
    function StableService(http$$1, store$$1) {
        this.http = http$$1;
        this.store = store$$1;
        this.onStoreStable$ = new BehaviorSubject.BehaviorSubject(false);
        this.storeStable$ = this.onStoreStable$.distinctUntilChanged();
    }
    /**
     * @return {?}
     */
    StableService.prototype.init = function () {
        var _this = this;
        this.store.subscribe(function () {
            window.storeStable = false;
            _this.onStoreStable$.next(false);
            if (_this.http.activeRequests === 0) {
                window.storeStable = true;
                _this.onStoreStable$.next(true);
            }
        });
    };
    return StableService;
}());
StableService.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
StableService.ctorParameters = function () { return [
    { type: RestService, },
    { type: store.NgRedux, },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class that builds the root reducer for redux from all injected [[APP_REDUCERS]].
 *
 * @export
 */
var RootReducer = /** @class */ (function () {
    /**
     * @param {?} reducerConfigs
     */
    function RootReducer(reducerConfigs) {
        this.reducerConfigs = reducerConfigs;
        this.currentReducers = {};
    }
    /**
     *
     *
     * \@memberof RootReducer
     * @param {?=} newReducerConfigs
     * @return {?}
     */
    RootReducer.prototype.reducer = function (newReducerConfigs) {
        return /** @type {?} */ (reduxBatchedActions.enableBatching(reduxImmutable.combineReducers(this.buildReducers(newReducerConfigs))));
    };
    /**
     * Builds the root reducer.
     *
     * \@memberof RootReducer
     * @param {?=} newReducerConfigs
     * @return {?}
     */
    RootReducer.prototype.buildReducers = function (newReducerConfigs) {
        var /** @type {?} */ currentReducers = Object.assign({}, this.currentReducers);
        var /** @type {?} */ reducerConfigs = newReducerConfigs
            ? newReducerConfigs
            : this.reducerConfigs;
        this.currentReducers = reducerConfigs.reduce(function (r, config) {
            if (typeof ((config.reducer)).reducer === 'function') {
                r[config.name] = ((config.reducer)).reducer();
            }
            else {
                r[config.name] = config.reducer;
            }
            return r;
        }, currentReducers);
        return this.currentReducers;
    };
    return RootReducer;
}());
RootReducer.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
RootReducer.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: core.Inject, args: [APP_REDUCERS,] },] },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} action$
 * @return {?}
 */
function dummyEpic(action$) {
    return action$.mergeMap(function () {
        return Observable.Observable.empty();
    });
}
/**
 * Wrapper class to activate all injected [[Epic]] instances and forward them to the redux-observable middleware.
 *
 * @export
 */
var RootEpic = /** @class */ (function () {
    /**
     * @param {?} epicConfigs
     */
    function RootEpic(epicConfigs) {
        this.epicConfigs = epicConfigs;
        var /** @type {?} */ epics = this.buildEpics(epicConfigs);
        this.middleware = reduxObservable.createEpicMiddleware(reduxObservable.combineEpics.apply(void 0, __spread(epics)));
    }
    /**
     * Returns the Root Epic given to the middleware
     *
     * \@memberof RootEpic
     * @return {?}
     */
    RootEpic.prototype.epic = function () {
        return reduxObservable.combineEpics.apply(void 0, __spread(this.epicConfigs));
    };
    /**
     * This method collects the [[Epic]] functions from the injected APP_EPICS and extracts the function
     * from [[IEpicClass]] if given.
     *
     * @protected
     * \@memberof RootEpic
     * @param {?} epicConfigs
     * @return {?}
     */
    RootEpic.prototype.buildEpics = function (epicConfigs) {
        return epicConfigs.map(function (config) {
            if (((config)).epic) {
                return ((config)).epic();
            }
            else {
                return /** @type {?} */ (config);
            }
        });
    };
    return RootEpic;
}());
RootEpic.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
RootEpic.ctorParameters = function () { return [
    { type: Array, decorators: [{ type: core.Inject, args: [APP_EPICS,] },] },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ɵ0$1 = { name: 'router', reducer: router.routerReducer };
var ɵ1 = dummyEpic;
var ReduxModule = /** @class */ (function () {
    function ReduxModule() {
    }
    return ReduxModule;
}());
ReduxModule.decorators = [
    { type: core.NgModule, args: [{
                providers: [
                    RootReducer,
                    RootEpic,
                    {
                        multi: true,
                        provide: APP_REDUCERS,
                        useValue: ɵ0$1,
                    },
                    { provide: APP_EPICS, useValue: ɵ1, multi: true },
                ],
            },] },
];
/** @nocollapse */
ReduxModule.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgxUtilsModule = /** @class */ (function () {
    function NgxUtilsModule() {
    }
    return NgxUtilsModule;
}());
NgxUtilsModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [AppTranslateModule, ReduxModule],
                exports: [AppTranslateModule, ReduxModule],
                providers: [StableService, RestService]
            },] },
];
/** @nocollapse */
NgxUtilsModule.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function random() {
    return 42;
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */
/**
 * Generates action names via naming convention based on [[observableMiddleware]].
 *
 * With the given baseName 'PRODUCT' it returns the object
 * ```
 * {
 *   base:  'PRODUCT',
 *   start: 'PRODUCT_START',
 *   next:  'PRODUCT_NEXT',
 *   error: 'PRODUCT_ERROR'
 * }
 * ```
 *
 * @export
 * @param {?} baseName
 * @return {?}
 */
function generateAsyncActionNames(baseName) {
    return {
        base: baseName,
        start: baseName + '_START',
        next: baseName + '_NEXT',
        error: baseName + '_ERROR',
    };
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */
/**
 * Small wrapper around Immutable.fromJS, that sets correct typings.
 *
 * Using this method we can create a [[Map]] that will typecheck keys
 * and forbids adding new keys.
 * @template T
 * @param {?} o
 * @return {?}
 */
function createImmutableState(o) {
    return /** @type {?} */ (immutable.fromJS(o));
}
/**
 * Returns the merge result of the given state and the diff, while ensuring diff is an immutable before merge.
 *
 * @template T, D
 * @param {?} state
 * @param {?} diff
 * @return {?}
 */
function mergeState(state, diff) {
    return state.merge(immutable.fromJS(diff));
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function createNormalizedEntityState() {
    return createImmutableState({
        result: '',
        entities: /** @type {?} */ (immutable.Map()),
        loading: false,
        loaded: false,
        updating: false,
        updatedAt: 0,
        error: null,
    });
}
/**
 * This creates a reducer with full CRUD functionality for a single entity.
 *
 * Requirement: Data received from API is normalized, see https://github.com/paularmstrong/normalizr
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @param {?=} customReducers
 * @return {?}
 */
function normalizedEntityReducerFactory(entityName, namespace, customReducers) {
    var /** @type {?} */ initialState = createNormalizedEntityState();
    return function (state, action) {
        if (state === void 0) { state = initialState; }
        var /** @type {?} */ actionNames = generateCrudActionNames(entityName, namespace);
        var /** @type {?} */ defaultReducers = (_a = {}, _a[actionNames.readOneStart] = function (s, a) {
                return mergeState(initialState, { loading: true });
            }, _a[actionNames.readOneNext] = function (s, a) {
                return mergeState(s, {
                    loading: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: immutable.fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            }, _a[actionNames.readOneError] = function (s, a) {
                return mergeState(initialState, {
                    error: a.payload,
                });
            }, _a[actionNames.createStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.createNext] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: immutable.fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            }, _a[actionNames.createError] = function (s, a) {
                return mergeState(initialState, { updating: false, error: a.payload });
            }, _a[actionNames.updateStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.updateNext] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: immutable.fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            }, _a[actionNames.updateError] = function (s, a) {
                return mergeState(s, { updating: false, error: a.payload });
            }, _a[actionNames.deleteStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.deleteNext] = function (s, a) {
                return initialState;
            }, _a[actionNames.deleteError] = function (s, a) {
                return mergeState(s, { updating: false, error: a.payload });
            }, _a[actionNames.setCurrent] = function (s, a) {
                return mergeState(initialState, {
                    loaded: true,
                    entities: immutable.fromJS(a.payload.entities),
                    result: a.payload.result,
                });
            }, _a[actionNames.reset] = function (s, a) {
                return initialState;
            }, _a[actionNames.resetError] = function (s, a) {
                return s.set('error', null);
            }, _a);
        var /** @type {?} */ reducers = Object.assign({}, defaultReducers, customReducers);
        if (reducers[action.type]) {
            return reducers[action.type](state, action);
        }
        return state;
        var _a;
    };
}
/**
 * @return {?}
 */
function createNormalizedCollectionState() {
    return createImmutableState({
        result: /** @type {?} */ ([]),
        entities: /** @type {?} */ ({}),
        loading: false,
        loaded: false,
        updating: false,
        updatedAt: 0,
        error: null,
    });
}
/**
 * This creates a reducer with full CRUD functionality for a collection of entities.
 *
 * Requirement: Data received from API is normalized, see https://github.com/paularmstrong/normalizr
 *
 * @export
 * @param {?} entityName
 * @param {?=} namespace
 * @param {?=} customReducers
 * @return {?}
 */
function normalizedCollectionReducerFactory(entityName, namespace, customReducers) {
    var /** @type {?} */ initialState = createNormalizedCollectionState();
    return function (state, action) {
        if (state === void 0) { state = initialState; }
        var /** @type {?} */ actionNames = generateCrudActionNames(entityName, namespace);
        var /** @type {?} */ defaultReducers = (_a = {}, _a[actionNames.readStart] = function (s, a) {
                return mergeState(initialState, { loading: true });
            }, _a[actionNames.readNext] = function (s, a) {
                return mergeState(s, {
                    loading: false,
                    loaded: true,
                    updatedAt: Date.now(),
                    entities: immutable.fromJS(action.payload.entities),
                    result: action.payload.result,
                });
            }, _a[actionNames.readError] = function (s, a) {
                return mergeState(initialState, { error: a.payload });
            }, _a[actionNames.createStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.createNext] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').mergeDeep(immutable.fromJS(a.payload.entities)),
                    result: s.get('result').push(a.payload.result),
                });
            }, _a[actionNames.createError] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            }, _a[actionNames.updateStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.updateNext] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').mergeDeep(immutable.fromJS(a.payload.entities)),
                });
            }, _a[actionNames.updateError] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            }, _a[actionNames.deleteStart] = function (s, a) {
                return mergeState(s, { updating: true, error: null });
            }, _a[actionNames.deleteNext] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    entities: s.get('entities').deleteIn([entityName, a.payload.result]),
                    result: s
                        .get('result')
                        .update(function (ids) { return ids.filterNot(function (id) { return id === a.payload.result; }); }),
                });
            }, _a[actionNames.deleteError] = function (s, a) {
                return mergeState(s, {
                    updating: false,
                    error: a.payload,
                });
            }, _a[actionNames.reset] = function (s, a) {
                return initialState;
            }, _a[actionNames.resetError] = function (s, a) {
                return s.set('error', null);
            }, _a);
        var /** @type {?} */ reducers = Object.assign({}, defaultReducers, customReducers);
        if (reducers[action.type]) {
            return reducers[action.type](state, action);
        }
        return state;
        var _a;
    };
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Small wrapper around reselect [[createSelector]], that knows how to compare ImmutableJS data structures.
 */
var createSelector = reselect.createSelectorCreator(reselect.defaultMemoize, immutable.is);
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Creates selectors for a reducer based on a [[INormalizedEntityState]].
 *
 * Provides base selectors for all attributes and also for building a [[Record]] instance out of the raw data
 *
 * @export
 * @template T
 * @param {?} entityName
 * @param {?} entityClass The [[Record.Class]] class to build the model from
 * @param {?} schema The same schema that was used no normalize the data in the first place
 * @param {?=} customSelectors
 * @return {?}
 */
function normalizedEntitySelectorFactory(entityName, entityClass, schema, customSelectors) {
    if (customSelectors === void 0) { customSelectors = {}; }
    var /** @type {?} */ baseSelector = function (state) { return state.get(entityName); };
    var /** @type {?} */ idSelector = function (state) { return baseSelector(state).get('result'); };
    var /** @type {?} */ entitiesSelector = function (state) { return baseSelector(state).get('entities'); };
    var /** @type {?} */ modelSelector = createSelector([idSelector, entitiesSelector], function (id, entities) {
        if (id) {
            var /** @type {?} */ denormalizedData = normalizr.denormalize(id, schema, entities);
            return new entityClass(denormalizedData);
        }
        else {
            return new entityClass();
        }
    });
    return Object.assign({}, {
        subStateSelector: baseSelector,
        loadingSelector: function (state) { return baseSelector(state).get('loading'); },
        loadedSelector: function (state) { return baseSelector(state).get('loaded'); },
        updatingSelector: function (state) { return baseSelector(state).get('updating'); },
        updatedAtSelector: function (state) { return baseSelector(state).get('updatedAt'); },
        idSelector: idSelector,
        modelSelector: modelSelector,
    }, customSelectors);
}
/**
 * Creates selectors for a reducer based on a [[INormalizedCollectionState]].
 *
 * Provides base selectors for all attributes and also for building a collection of [[Record]] instances out of the raw data
 *
 * @export
 * @template T
 * @param {?} entityName
 * @param {?} entityClass The [[Record.Class]] class to build the models from
 * @param {?} schema The same schema that was used no normalize the data in the first place
 * @param {?=} customSelectors
 * @return {?}
 */
function normalizedCollectionSelectorsFactory(entityName, entityClass, schema, customSelectors) {
    if (customSelectors === void 0) { customSelectors = {}; }
    var /** @type {?} */ baseSelector = function (state) { return state.get(entityName); };
    var /** @type {?} */ idsSelector = function (state) { return baseSelector(state).get('result'); };
    var /** @type {?} */ entitiesSelector = function (state) { return baseSelector(state).get('entities'); };
    var /** @type {?} */ modelsSelector = createSelector([idsSelector, entitiesSelector], function (ids, entities) {
        var /** @type {?} */ denormalizedData = normalizr.denormalize(ids, schema, entities);
        return denormalizedData.map(function (item) { return new entityClass(item); });
    });
    var /** @type {?} */ modelsMapSelector = createSelector([modelsSelector], function (models) {
        return models.reduce(function (acc, item) {
            return acc.set(String(item.get('id', null)), item);
        }, immutable.Map());
    });
    return Object.assign({}, {
        subStateSelector: baseSelector,
        loadingSelector: function (state) { return baseSelector(state).get('loading'); },
        loadedSelector: function (state) { return baseSelector(state).get('loaded'); },
        updatingSelector: function (state) { return baseSelector(state).get('updating'); },
        updatedAtSelector: function (state) { return baseSelector(state).get('updatedAt'); },
        idsSelector: idsSelector,
        modelsSelector: modelsSelector,
        modelsMapSelector: modelsMapSelector,
    }, customSelectors);
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Base class for Environment settings.
 *
 * Subclass this to add a real Environment to your app.
 *
 * @export
 * @abstract
 * @abstract
 */
var DefaultEnvironment = /** @class */ (function () {
    function DefaultEnvironment() {
        this.production = false;
        /**
         * Base API URL for current Environment, used by [[RestService]]
         *
         * \@memberof DefaultEnvironment
         */
        this.apiUrl = '';
        /**
         * Thow if a given JSON Schema produces a validation error on data?
         *
         * \@memberof DefaultEnvironment
         */
        this.throwOnSchemaError = true;
        /**
         * Ask user for confirmation to relaod the page after a ServiceWorker update?
         *
         * \@memberof DefaultEnvironment
         */
        this.autoUpdate = 'always';
        this.updateMessage = 'A new version of the app is available. Do you want to reload the page to update?';
        /**
         * HTML <title> tag
         *
         * \@memberof DefaultEnvironment
         */
        this.pageTitle = 'DCS Angular Starter';
        /**
         * What to set as <base href>
         *
         * see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base
         *
         * \@memberof DefaultEnvironment
         */
        this.base = '/';
        /**
         * Add app specific redux enhancers here.
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalEnhancers = [];
        /**
         * Add app specific middleware here.
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalMiddleware = [];
        /**
         * Add here, whatever additional settings your app needs
         *
         * \@memberof DefaultEnvironment
         */
        this.additionalSettings = {};
    }
    return DefaultEnvironment;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DefaultErrorHandler = /** @class */ (function () {
    function DefaultErrorHandler() {
    }
    /**
     * @param {?} error
     * @return {?}
     */
    DefaultErrorHandler.prototype.handleError = function (error) {
        // clean up potential broken persisted state if an error bubbles up to the global handler
        localStorage.clear();
        throw error;
    };
    return DefaultErrorHandler;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Given a JSON schema, this compiles a validator function to use later
 *
 * Basically a small wrapper around [[Ajv]]
 *
 * @export
 * @param {?} jsonSchema
 * @param {?=} ajv
 * @return {?}
 */
function buildSchemaValidator(jsonSchema, ajv) {
    if (!ajv) {
        ajv = new Ajv({ allErrors: true });
    }
    return ajv.compile(jsonSchema);
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} recordClass
 * @return {?}
 */
function EmbeddedRecord(recordClass) {
    return function (target, key) {
        var /** @type {?} */ cache = new WeakMap();
        return {
            /**
             * @return {?}
             */
            get: function () {
                if (!cache.has(this)) {
                    cache.set(this, new recordClass(this.get(key)));
                }
                return cache.get(this);
            }
        };
    };
}
/**
 * @param {?} recordClass
 * @param {?=} collectionFactory
 * @return {?}
 */
function EmbeddedCollection(recordClass, collectionFactory) {
    if (collectionFactory === void 0) { collectionFactory = immutable.List; }
    return function (target, key) {
        var /** @type {?} */ cache = new WeakMap();
        return {
            /**
             * @return {?}
             */
            get: function () {
                if (!cache.has(this)) {
                    var /** @type {?} */ collection = this.get(key) || collectionFactory();
                    cache.set(this, collectionFactory(collection.map(function (data) { return new recordClass(data); })));
                }
                return cache.get(this);
            }
        };
    };
}
/**
 * @template TBase
 * @param {?} Base
 * @return {?}
 */
function ExtendedRecord(Base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        /**
         * @param {...?} args
         */
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = this;
            var /** @type {?} */ params = immutable.fromJS(args.shift());
            _this = _super.apply(this, __spread([params], args)) || this;
            return _this;
        }
        /**
         * @param {?} params
         * @return {?}
         */
        class_1.prototype.with = function (params) {
            return /** @type {?} */ (this.merge(immutable.fromJS(params)));
        };
        return class_1;
    }(Base));
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} c
 * @return {?}
 */
function validateEmail(c) {
    return validator.isEmail(String(c.value)) ? null : { validateEmail: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validatePhone(c) {
    return validator.isMobilePhone(String(c.value), 'de-DE')
        ? null
        : { validatePhone: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateFQDN(c) {
    return validator.isFQDN(String(c.value)) ? null : { validateFQDN: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validatePositiveInteger(c) {
    var /** @type {?} */ value = String(c.value);
    return validator.isInt(value, { min: 1 })
        ? null
        : { validatePositiveInteger: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateDate(c) {
    var /** @type {?} */ value = dateFns.parse(c.value, 'YYYY-MM-DD', 0);
    return dateFns.isValid(value) ? null : { validateDate: { valid: false } };
}
/**
 * @param {?} c
 * @return {?}
 */
function validateTime(c) {
    var /** @type {?} */ value = dateFns.parse(c.value, 'HH:mm', 0);
    return dateFns.isValid(value) ? null : { validateTime: { valid: false } };
}

exports.MainBaseModule = MainBaseModule;
exports.NgxUtilsModule = NgxUtilsModule;
exports.RestService = RestService;
exports.StableService = StableService;
exports.AppTranslateModule = AppTranslateModule;
exports.LocaleService = LocaleService;
exports.TranslateActions = TranslateActions;
exports.ContainerComponent = ContainerComponent;
exports.PresentationalComponent = PresentationalComponent;
exports.random = random;
exports.ReduxModule = ReduxModule;
exports.RootEpic = RootEpic;
exports.dummyEpic = dummyEpic;
exports.RootReducer = RootReducer;
exports.generateAsyncActionNames = generateAsyncActionNames;
exports.observableMiddleware = observableMiddleware;
exports.loggerMiddleware = loggerMiddleware;
exports.removeEmptyActionsMiddleware = removeEmptyActionsMiddleware;
exports.createNormalizedEntityState = createNormalizedEntityState;
exports.normalizedEntityReducerFactory = normalizedEntityReducerFactory;
exports.createNormalizedCollectionState = createNormalizedCollectionState;
exports.normalizedCollectionReducerFactory = normalizedCollectionReducerFactory;
exports.normalizedEntitySelectorFactory = normalizedEntitySelectorFactory;
exports.normalizedCollectionSelectorsFactory = normalizedCollectionSelectorsFactory;
exports.generateCrudActionNames = generateCrudActionNames;
exports.subStateStale = subStateStale;
exports.hasModel = hasModel;
exports.createImmutableState = createImmutableState;
exports.mergeState = mergeState;
exports.createSelector = createSelector;
exports.createReduxStore = createReduxStore;
exports.persistStateEnhancer = persistStateEnhancer;
exports.routerStateSelector = routerStateSelector;
exports.APP_REDUCERS = APP_REDUCERS;
exports.APP_EPICS = APP_EPICS;
exports.APP_ERROR_FORMATTERS = APP_ERROR_FORMATTERS;
exports.APP_TRANSLATIONS = APP_TRANSLATIONS;
exports.APP_ENVIRONMENT = APP_ENVIRONMENT;
exports.DefaultEnvironment = DefaultEnvironment;
exports.DefaultErrorHandler = DefaultErrorHandler;
exports.buildSchemaValidator = buildSchemaValidator;
exports.EmbeddedRecord = EmbeddedRecord;
exports.EmbeddedCollection = EmbeddedCollection;
exports.ExtendedRecord = ExtendedRecord;
exports.validateEmail = validateEmail;
exports.validatePhone = validatePhone;
exports.validateFQDN = validateFQDN;
exports.validatePositiveInteger = validatePositiveInteger;
exports.validateDate = validateDate;
exports.validateTime = validateTime;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dcs-ngx-utils.umd.js.map
